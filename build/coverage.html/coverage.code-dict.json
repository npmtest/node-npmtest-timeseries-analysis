{"/home/travis/build/npmtest/node-npmtest-timeseries-analysis/test.js":"/* istanbul instrument in package npmtest_timeseries_analysis */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-timeseries-analysis/lib.npmtest_timeseries_analysis.js":"/* istanbul instrument in package npmtest_timeseries_analysis */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_timeseries_analysis = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_timeseries_analysis = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-timeseries-analysis/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-timeseries-analysis && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_timeseries_analysis */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_timeseries_analysis\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_timeseries_analysis.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_timeseries_analysis.rollup.js'] =\n            local.assetsDict['/assets.npmtest_timeseries_analysis.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_timeseries_analysis.__dirname + '/lib.npmtest_timeseries_analysis.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-timeseries-analysis/node_modules/timeseries-analysis/timeseries-analysis.js":"var \t\t\t_ = require(\"underscore\");\nvar gimage \t\t= require('google-image-chart').charts;\n\nvar timeseries = function(data, options) {\n\t/*\n\t\tData Format:\n\t\t[\n\t\t\t[Date Object, value],\n\t\t\t[Date Object, value]\n\t\t]\n\t*/\n\tthis.options \t= _.extend({\n\t\t\n\t}, options);\n\t\n\tthis.data \t\t= data;\n\tthis.original\t= data.slice(0);\n\tthis.buffer \t= [];\n\tthis.saved \t\t= [];\n\t\n\treturn this;\n}\n\n\n// Output the data\ntimeseries.prototype.output = function() {\n\treturn this.data;\n}\n\n\n// Save the data\ntimeseries.prototype.save = function(name, options) {\n\toptions = _.extend({\n\t\tcolor:\t'AUTO'\n\t}, options);\n\t\n\tthis.saved.push({\n\t\tname:\tname,\n\t\tcolor:\toptions.color,\n\t\tdata:\tthis.data.slice(0)\n\t});\n\treturn this;\n}\n\n// Chart the data\ntimeseries.prototype.chart = function(options) {\n\t\n\toptions = _.extend({\n\t\tmain:\t\tfalse,\n\t\twidth:\t\t800,\n\t\theight:\t\t200,\n\t\tbands:\t\t[],\n\t\tlines:\t\t[],\n\t\tpoints:\t\t[]\n\t}, options);\n\t\n\t// Google Chart\n\tvar chart = new gimage.line({\n\t\twidth:\toptions.width,\n\t\theight:\toptions.height,\n\t\tbands:\toptions.bands,\n\t\thlines:\toptions.lines,\n\t\tpoints:\toptions.points,\n\t\tautoscale:\ttrue\n\t});\n\tchart.fromTimeseries(this.data);\n\t// Include the original data\n\tif (options.main) {\n\t\tchart.fromTimeseries(this.original);\n\t}\n\t\n\t// Include saved data\n\t_.each(this.saved, function(saved) {\n\t\tchart.fromTimeseries(saved.data);\n\t});\n\t\n\treturn chart.render();\n}\n\n\n// Basic utilities: Array fill, data cloning...\n// Returns an array filled with the specified value.\ntimeseries.prototype.fill = function(value, n) {\n\tvar array = [];\n\tvar i;\n\tfor (i=0;i<n;i++) {\n\t\tarray.push(value);\n\t}\n\treturn array;\n}\n\n// Returns a clone of the data\ntimeseries.prototype.clone = function() {\n\tvar buffer = _.map(this.data, function(point) {\n\t\treturn [\n\t\t\tpoint[0],\n\t\t\tpoint[1]*1\n\t\t];\n\t});\n\treturn buffer;\n}\n\n// Reset the data to its original dataset\ntimeseries.prototype.reset = function() {\n\tthis.data = this.original;\n\treturn this;\n}\n\n// Convert the data to a 1D array\ntimeseries.prototype.toArray = function() {\n\treturn _.map(this.data, function(datapoint) {\n\t\treturn  datapoint[1];\n\t});\n}\n\n// Stats: Min, Max, Mean, Stdev\ntimeseries.prototype.min = function() {\n\tvar array = this.toArray();\n\treturn _.min(array);\n}\ntimeseries.prototype.max = function() {\n\tvar array = this.toArray();\n\treturn _.max(array);\n}\ntimeseries.prototype.mean = function(data) {\n\tif (!data) {\n\t\tvar data = this.data;\n\t}\n\tvar sum \t= 0;\n\tvar n \t\t= 0;\n\t_.each(data, function(datapoint) {\n\t\tsum += datapoint[1];\n\t\tn++;\n\t});\n\treturn sum/n;\n}\ntimeseries.prototype.stdev = function(data) {\n\tif (!data) {\n\t\tvar data = this.data;\n\t}\n\tvar sum \t= 0;\n\tvar n \t\t= 0;\n\tvar mean \t= this.mean();\n\t_.each(data, function(datapoint) {\n\t\tsum += (datapoint[1]-mean)*(datapoint[1]-mean);\n\t\tn++;\n\t});\n\treturn Math.sqrt(sum/n);\n}\n\n\n// Offet the data\ntimeseries.prototype.offset = function(value, data, ret) {\n\tif (!data) {\n\t\tvar data = this.data;\n\t}\n\tvar i;\n\tvar j;\n\tvar l \t= data.length;\n\tvar sum\t= 0;\n\t\n\t// Reset the buffer\n\tthis.buffer \t= data.slice(0);\n\t\n\tfor (i=0;i<l;i++) {\n\t\tthis.buffer[i] = [\n\t\t\tthis.buffer[i][0],\n\t\t\tthis.buffer[i][1]+value\n\t\t];\n\t}\n\tif (!ret) {\n\t\tthis.data = this.buffer;\n\t\treturn this;\n\t} else {\n\t\treturn this.buffer;\n\t}\n}\n\n\n\n\n\n// Moving Average\ntimeseries.prototype.ma = function(options) {\n\toptions = _.extend({\n\t\tperiod:\t\t12\n\t}, options);\n\tvar i;\n\tvar j;\n\tvar l \t= this.data.length;\n\tvar sum\t= 0;\n\t\n\t// Reset the buffer\n\tthis.buffer \t= [];\n\t\n\t// Leave the datapoints [0;period[ intact\n\tthis.buffer = this.data.slice(0, options.period);\n\t\n\tfor (i=options.period;i<l;i++) {\n\t\tsum\t= 0;\n\t\tfor (j=options.period;j>0;j--) {\n\t\t\tsum += this.data[i-j][1];\n\t\t}\n\t\tthis.buffer[i] = [this.data[i][0], sum/options.period];\n\t}\n\tthis.data = this.buffer;\n\treturn this;\n}\ntimeseries.prototype.ema = function(options) {\n\toptions = _.extend({\n\t\tperiod:\t\t12\n\t}, options);\n\tvar i;\n\tvar j;\n\tvar l \t= this.data.length;\n\tvar sum\t= 0;\n\t\n\t// Reset the buffer\n\tthis.buffer \t= [];\n\t\n\t// Leave the datapoints [0;period[ intact\n\tthis.buffer = this.data.slice(0, options.period);\n\t\n\tvar m\t= 2/(options.period+1);\t// Multiplier\n\t\n\tfor (i=options.period;i<l;i++) {\n\t\tthis.buffer[i] = [\n\t\t\tthis.data[i][0],\n\t\t\t(this.data[i][1]-this.data[i-1][1])*m+this.data[i-1][1]\n\t\t];\n\t}\n\tthis.data = this.buffer;\n\treturn this;\n}\ntimeseries.prototype.lwma = function(options) {\n\toptions = _.extend({\n\t\tperiod:\t\t12\n\t}, options);\n\tvar i;\n\tvar j;\n\tvar l \t= this.data.length;\n\tvar sum\t= 0;\n\tvar n\t= 0;\n\t\n\t// Reset the buffer\n\tthis.buffer \t= [];\n\t\n\t// Leave the datapoints [0;period[ intact\n\tthis.buffer = this.data.slice(0, options.period);\n\t\n\tfor (i=options.period;i<l;i++) {\n\t\tsum\t= 0;\n\t\tn\t= 0;\n\t\tfor (j=options.period;j>0;j--) {\n\t\t\tsum += this.data[i-j][1]*j;\n\t\t\tn += j;\n\t\t}\n\t\tthis.buffer[i] = [this.data[i][0], sum/n];\n\t}\n\tthis.data = this.buffer;\n\treturn this;\n}\n\n\n\n// DSL, iTrend\ntimeseries.prototype.dsp_itrend = function(options) {\n\t// By Ehler\n\t// http://www.davenewberg.com/Trading/TS_Code/Ehlers_Indicators/iTrend_Ind.html\n\toptions = _.extend({\n\t\talpha:\t\t0.7,\n\t\tuse:\t\t'main'\n\t}, options);\n\tvar i;\n\tvar j;\n\tvar l \t= this.data.length;\n\t\n\tvar trigger \t= [];\n\t\n\t// Reset the buffer\n\tthis.buffer \t= [];\n\t\n\t// Leave the datapoints [0;period[ intact\n\tthis.buffer \t= this.data.slice(0, 3);\n\tthis.trigger \t= this.data.slice(0, 3);\n\t\n\tfor (i=3;i<l;i++) {\n\t\tthis.buffer[i] = [\n\t\t\tthis.data[i][0],\n\t\t\t(options.alpha-(options.alpha*options.alpha)/4)*this.data[i][1] + (0.5*(options.alpha*options.alpha)*this.data[i-1][1]) - (options.alpha - 0.75*(options.alpha*options.alpha)) * this.data[i-2][1] + 2*(1-options.alpha)*this.buffer[i-1][1] - (1-options.alpha)*(1-options.alpha)*this.buffer[i-2][1]\n\t\t];\n\t\tthis.trigger[i] = [\n\t\t\tthis.data[i][0],\n\t\t\t2*this.buffer[i][1]-this.buffer[i-2][1]\n\t\t]\n\t}\n\tif (options.use == 'trigger') {\n\t\tthis.data = this.trigger;\n\t} else{\n\t\tthis.data = this.buffer;\n\t}\n\t\n\treturn this;\n}\n\n\n// Pixelize - Domain reduction\ntimeseries.prototype.pixelize = function(options) {\n\toptions = _.extend({\n\t\tgrid:\t\t20\n\t}, options);\n\t\n\t// Calculate the grid values\n\tvar min \t= this.min();\n\tvar max \t= this.max();\n\tvar tile\t= (max-min)/options.grid;\n\t\n\tthis.buffer\t= _.map(this.data, function(datapoint) {\n\t\tdatapoint[1] = Math.round(datapoint[1]/tile)*tile;\n\t\treturn datapoint;\n\t});\n\tthis.data = this.buffer;\n\treturn this;\n}\n\n\n// Iterative Noise Removal\ntimeseries.prototype.smoother = function(options) {\n\toptions = _.extend({\n\t\tperiod:\t\t1\n\t}, options);\n\tvar i;\n\tvar j;\n\tvar l \t= this.data.length;\n\tvar sum\t= 0;\n\t\n\t// Reset the buffer\n\tthis.buffer \t= this.data.slice(0);\n\t\n\tfor (j=0;j<options.period;j++) {\n\t\tfor (i=3;i<l;i++) {\n\t\t\tthis.buffer[i-1] = [\n\t\t\t\tthis.buffer[i-1][0],\n\t\t\t\t(this.buffer[i-2][1]+this.buffer[i][1])/2\n\t\t\t];\n\t\t}\n\t}\n\tthis.data = this.buffer;\n\treturn this;\n}\n\n\n// Extract the noise out of the data\ntimeseries.prototype.noiseData = function() {\n\tvar i;\n\tvar j;\n\tvar l \t= this.data.length;\n\tvar sum\t= 0;\n\t\n\t// Reset the buffer\n\tthis.buffer \t= [];\n\t\n\tfor (i=0;i<l;i++) {\n\t\tthis.buffer[i] = [\n\t\t\tthis.data[i][0],\n\t\t\tthis.original[i][1]-this.data[i][1]\n\t\t];\n\t}\n\tthis.data = this.buffer;\n\treturn this;\n}\n\n\n// Oscillator function\ntimeseries.prototype.osc = function() {\n\tvar i;\n\tvar j;\n\tvar l \t= this.data.length;\n\tvar sum\t= 0;\n\t\n\t// Reset the buffer\n\tthis.buffer \t= [];\n\t\n\tfor (i=0;i<l;i++) {\n\t\tif (i<=1) {\n\t\t\tthis.buffer[i] = [\n\t\t\t\tthis.data[i][0],\n\t\t\t\t0\n\t\t\t];\n\t\t} else {\n\t\t\tthis.buffer[i] = [\n\t\t\t\tthis.data[i][0],\n\t\t\t\tthis.data[i][1]-this.data[i-1][1]\n\t\t\t];\n\t\t}\n\t}\n\tthis.data = this.buffer;\n\treturn this;\n}\n\n\n\n// Find the supports and resistances. Wrong algorithm.\ntimeseries.prototype.supports = function(options) {\n\toptions = _.extend({\n\t\tgrid:\t\t40,\n\t\tthreshold:\t10\n\t}, options);\n\t\n\t// Calculate the grid values\n\tvar min \t= this.min();\n\tvar max \t= this.max();\n\tvar tile\t= (max-min)/options.grid;\n\t\n\tvar prices = {\n\t\t\n\t};\n\t\n\t_.each(this.data, function(datapoint) {\n\t\tvar val = Math.round(datapoint[1]/tile)*tile;\n\t\tif (!prices[val]) {\n\t\t\tprices[val] = 0;\n\t\t}\n\t\tprices[val]++;\n\t});\n\t\n\tvar ordered = [];\n\tvar i;\n\tfor (i in prices) {\n\t\tordered.push({\n\t\t\tprice:\ti,\n\t\t\tcount:\tprices[i]\n\t\t});\n\t}\n\tordered = ordered.sort(function(a,b) {\n\t\treturn b.count-a.count;\n\t});\n\tordered\t= _.filter(ordered, function(support) {\n\t\treturn support.count >= options.threshold;\n\t});\n\tif (options.stats) {\n\t\treturn \tordered;\n\t}\n\t\n\treturn _.map(ordered, function(support) {\n\t\treturn support.price;\n\t});\n}\n\n\n// Standardize the data\ntimeseries.prototype.standardize = function(options) {\n\toptions = _.extend({}, options);\n\t\n\tvar stdev\t= this.stdev();\n\tvar mean\t= this.mean();\n\t\n\tthis.data = _.map(this.data, function(datapoint) {\n\t\tdatapoint[1] = (datapoint[1]-mean)/stdev;\n\t\treturn datapoint;\n\t});\n\t\n\treturn this;\n}\n\n\n// Slice the data\ntimeseries.prototype.slice = function(from, to) {\n\tif (!from) {\n\t\tfrom = 0;\n\t}\n\tif (!to) {\n\t\tto = this.data.length-1;\n\t}\n\t\n\tthis.data = this.data.splice(from, to)\n\t\n\treturn this;\n}\n\n\n// Find the cycle in the data\ntimeseries.prototype.cycle = function(options) {\n\toptions = _.extend({\n\t\tperiod:\t\t10,\n\t\tforecast:\tfalse,\n\t\tforecast_length:\t20\n\t}, options);\n\t\n\t// Smooth the data\n\tthis.smoother(options);\n\t\n\t\n\t\n\t// Copy the data\n\tvar buffer \t\t\t\t= [];\n\tvar buffer_forecast \t= [];\n\t\n\tvar i;\n\tvar j;\n\tvar l = this.data.length;\n\tfor (i=0;i<2;i++) {\n\t\tbuffer[i] = ([\n\t\t\tthis.data[i][0],\n\t\t\tthis.data[i][1]\n\t\t]);\n\t\tbuffer_forecast[i] = ([\n\t\t\tthis.data[i][0],\n\t\t\tthis.data[i][1]\n\t\t]);\n\t}\n\tfor (i=2;i<l;i++) {\n\t\t// We find the ratio\n\t\tvar d1 \t\t= this.data[i][1]-this.data[i-1][1];\n\t\tvar d2 \t\t= this.data[i][1]-this.data[i-2][1];\n\t\tvar ratio\t= d1/d2;\n\t\tconsole.log(\"ratio\",ratio, d1, d2);\n\t\tbuffer[i] = ([\n\t\t\tthis.data[i][0],\n\t\t\tthis.data[i][1]\n\t\t]);\n\t\t\n\t\tbuffer_forecast[i] = ([\n\t\t\tthis.data[i][0],\n\t\t\tthis.data[i][1],\n\t\t\tratio,\n\t\t\td1>0,\n\t\t\td2>0\n\t\t]);\n\t\t\n\t}\n\t\n\tif (options.forecast) {\n\t\tfor (i=2;i<l;i++) {\n\t\t\tif (options.forecast == i) {\n\t\t\t\t\n\t\t\t\t// Generate a two cycles sin wave\n\t\t\t\tvar sin = [];\n\t\t\t\tfor (j=0;j<720;j++) {\n\t\t\t\t\tsin.push(Math.sin(j*Math.PI/180));\n\t\t\t\t}\n\t\t\t\tconsole.log(\"sin\",sin);\n\t\t\t\t\n\t\t\t\t// Find the closest sin wave\n\t\t\t\tvar MSE = [];\n\t\t\t\tvar minMSE\t= 10000000;\n\t\t\t\tvar pos;\n\t\t\t\tfor (j=2;j<720;j++) {\n\t\t\t\t\tvar d1 \t\t= sin[j]-sin[j-1];\n\t\t\t\t\tvar d2 \t\t= sin[j]-sin[j-2];\n\t\t\t\t\tvar ratio\t= d1/d2;\n\t\t\t\t\tvar mse\t\t= (ratio-buffer_forecast[i][2])*(ratio-buffer_forecast[i][2]);\n\t\t\t\t\tif (mse <= minMSE && ((d1>0)==buffer_forecast[i][3]) && ((d2>0)==buffer_forecast[i][3])) {\n\t\t\t\t\t\tminMSE \t= mse;\n\t\t\t\t\t\tpos\t\t= j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconsole.log(\"minMSE\",minMSE, pos);\n\t\t\t\t\n\t\t\t\tfor (j=0;j<=options.forecast_length;j++) {\n\t\t\t\t\tbuffer_forecast[i+j][1] = Math.sin((pos+j)*Math.PI/180);\n\t\t\t\t\t\n\t\t\t\t\t//buffer_forecast[i+j][1] = sin[pos+j];\n\t\t\t\t\t\n\t\t\t\t\tconsole.log(\"buffer_forecast[\"+(i+j)+\"]\", pos+j, buffer_forecast[i+j][1]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.data = buffer_forecast;\n\t} else {\n\t\tthis.data = buffer;\n\t}\n\t\n\treturn this;\n}\n\n\n// Get the outliers from the dataset\ntimeseries.prototype.outliers = function(options) {\n\t// Original code by Professor Hossein Arsham - http://home.ubalt.edu/ntsbarsh/Business-stat/otherapplets/Outlier.htm\n\t// Re-written for timeseries-analysis.\n\t\n\toptions = _.extend({\n\t\tthreshold:\t2.5\n\t}, options);\n\t\n\t\n\t// Create a copy of the data;\n\tthis.buffer \t= this.data.slice(0);\n\t\n\t// standardize the data\n\tthis.standardize();\n\t\n\tvar outliers = [];\n\t\n\t_.each(this.data, function(datapoint) {\n\t\tif (Math.abs(datapoint[1]) > options.threshold) {\n\t\t\toutliers.push(datapoint);\n\t\t}\n\t});\n\t\n\t// restore the data\n\tthis.data = this.buffer.slice(0);\n\tdelete this.buffer;\n\t\n\treturn outliers;\n}\n\n\n/* EXPERIMENTAL - AutoRegression Analysis */\n\ntimeseries.prototype.regression_forecast = function(options) {\n\toptions = _.extend({\n\t\tmethod:\t\t'ARMaxEntropy',\t// ARMaxEntropy | ARLeastSquare\n\t\tsample:\t\t50,\t\t// points int he sample\n\t\tstart:\t\t100,\t// Where to start\n\t\tn:\t\t\t5,\t\t// How many points to forecast\n\t\tdegree:\t\t5\n\t},options);\n\t\n\tvar i;\n\tvar j;\n\tvar l = this.data.length;\n\t\n\tvar mean\t= this.mean();\n\tthis.offset(-mean);\n\tvar backup \t= this.clone();\n\tvar buffer \t= this.clone();\n\t\n\tvar sample \t\t= buffer.slice(options.start-1-options.sample, options.start);\n\t\n\t// The current data to process is only a sample of the real data.\n\tthis.data\t\t= sample;\n\t// Get the AR coeffs\n\tvar coeffs \t\t= this[options.method]({degree: options.degree});\n\tconsole.log(\"coeffs\",coeffs);\n\t\n\tfor (i=options.start;i<options.start+options.n;i++) {\n\t\tbuffer[i][1]\t= 0;\n\t\tfor (j=0;j<coeffs.length;j++) {\n\t\t\tif (options.method == 'ARMaxEntropy') {\n\t\t\t\tbuffer[i][1] -= buffer[i-1-j][1]*coeffs[j];\n\t\t\t} else {\n\t\t\t\tbuffer[i][1] += buffer[i-1-j][1]*coeffs[j];\n\t\t\t}\n\t\t}\n\t\tconsole.log(\"buffer[\"+i+\"][1]\",buffer[i][1]);\n\t}\n\tthis.data = buffer;\n\tthis.offset(mean);\n\t\n\treturn this;\n}\n\ntimeseries.prototype.regression_forecast_optimize = function(options) {\n\toptions = _.extend({\n\t\tdata:\t\tthis.data,\n\t\tmaxPct:\t\t0.2,\n\t\tmaxSampleSize:\tfalse\n\t},options);\n\t\n\tvar l \t\t\t\t= options.data.length;\n\t\n\tvar maxSampleSize\t= Math.round(l*options.maxPct);\n\tif (options.maxSampleSize) {\n\t\tmaxSampleSize = Math.min(maxSampleSize, options.maxSampleSize);\n\t}\n\t\n\tvar maxDegree\t\t= Math.round(maxSampleSize);\n\tvar methods\t\t\t= ['ARMaxEntropy', 'ARLeastSquare'];\n\tvar ss;\t\t// sample size\n\tvar deg;\t// degree\n\tvar MSEData = [];\n\tvar i;\n\tfor (i=0;i<methods.length;i++) {\n\t\tfor (ss=3;ss<=maxSampleSize;ss++) {\n\t\t\tfor (deg=1;deg<=maxDegree;deg++) {\n\t\t\t\tif (deg<=ss) {\n\t\t\t\t\tvar mse = this.regression_forecast_mse({\n\t\t\t\t\t\tmethod:\tmethods[i],\n\t\t\t\t\t\tsample:\tss,\n\t\t\t\t\t\tdegree:\tdeg,\n\t\t\t\t\t\tdata:\toptions.data\n\t\t\t\t\t});\n\t\t\t\t\tconsole.log(\"Trying method(\"+methods[i]+\") degree(\"+deg+\") sample(\"+ss+\")\\t\"+mse);\n\t\t\t\t\tif (!isNaN(mse)) {\n\t\t\t\t\t\tMSEData.push({\n\t\t\t\t\t\t\tMSE:\tmse,\n\t\t\t\t\t\t\tmethod:\tmethods[i],\n\t\t\t\t\t\t\tdegree:\tdeg,\n\t\t\t\t\t\t\tsample:\tss\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Now we sort by MSE\n\tMSEData = MSEData.sort(function(a,b) {\n\t\treturn a.MSE>b.MSE;\n\t});\n\t\n\tconsole.log(\"Best Settings: \",MSEData[0]);\n\t\n\t// Return the best settings\n\treturn MSEData[0];\n\t\n}\n// Calculate the MSE for a forecast, for a set of parameters\ntimeseries.prototype.regression_forecast_mse = function(options) {\n\toptions = _.extend({\n\t\tmethod:\t\t'ARMaxEntropy',\t// ARMaxEntropy | ARLeastSquare\n\t\tsample:\t\t50,\n\t\tdegree:\t\t5,\n\t\tdata:\t\tthis.data\n\t},options);\n\t\n\t\n\tvar i;\n\tvar j;\n\tvar l \t\t\t= options.data.length;\n\t\n\tvar mean\t\t= this.mean(options.data);\n\toptions.data \t= this.offset(-mean, options.data, true);\n\t\n\tvar backup \t\t= _.map(options.data, function(item) {\n\t\treturn [\n\t\t\titem[0],\n\t\t\titem[1]*1\n\t\t];\n\t});\n\tvar buffer \t\t= _.map(options.data, function(item) {\n\t\treturn [\n\t\t\titem[0],\n\t\t\titem[1]*1\n\t\t];\n\t});\n\t\n\tvar MSE\t= 0;\n\tvar n = 0;\n\tfor (i=options.sample;i<l-1;i++) {\n\t\tvar sample \t\t= buffer.slice(i-options.sample, i);\n\t\t// Get the AR coeffs\n\t\tvar coeffs \t\t= this[options.method]({degree:options.degree, data:sample});\n\t\tvar knownValue \t= buffer[i+1][1]*1;\n\t\tbuffer[i+1][1]\t= 0;\n\t\tfor (j=0;j<coeffs.length;j++) {\n\t\t\tif (options.method == 'ARMaxEntropy') {\n\t\t\t\tbuffer[i+1][1] -= backup[i-j][1]*coeffs[j];\n\t\t\t} else {\n\t\t\t\tbuffer[i+1][1] += backup[i-j][1]*coeffs[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tMSE += (knownValue-buffer[i+1][1])*(knownValue-buffer[i+1][1]);\n\t\tn++;\n\t}\n\t\n\tMSE /= n;\n\t\n\t\n\t//this.data = buffer;\n\t\n\t// Put back the mean\n\t//this.offset(mean);\n\t\n\treturn MSE;\n}\ntimeseries.prototype.sliding_regression_forecast = function(options) {\n\toptions = _.extend({\n\t\tmethod:\t\t'ARMaxEntropy',\t// ARMaxEntropy | ARLeastSquare\n\t\tsample:\t\t50,\n\t\tdegree:\t\t5\n\t},options);\n\t\n\tvar i;\n\tvar j;\n\tvar l = this.data.length;\n\t\n\tvar mean\t= this.mean();\n\tthis.offset(-mean);\n\tvar backup \t= this.clone();\n\tvar buffer \t= this.clone();\n\t\n\tfor (i=options.sample;i<l-1;i++) {\n\t\tvar sample \t\t= buffer.slice(i-options.sample, i);\n\t\t// The current data to process is only a sample of the real data.\n\t\tthis.data\t\t= sample;\n\t\t// Get the AR coeffs\n\t\tvar coeffs \t\t= this[options.method]({degree:options.degree});\n\t\tbuffer[i+1][1]\t= 0; //backup[i][1]*1;\n\t\tfor (j=0;j<coeffs.length;j++) {\n\t\t\tif (options.method == 'ARMaxEntropy') {\n\t\t\t\tbuffer[i+1][1] -= backup[i-j][1]*coeffs[j];\n\t\t\t} else {\n\t\t\t\tbuffer[i+1][1] += backup[i-j][1]*coeffs[j];\n\t\t\t}\n\t\t}\n\t\t//buffer[i+1][1] -\n\t}\n\t\n\tthis.data = buffer;\n\t\n\t// Put back the mean\n\tthis.offset(mean);\n\t\n\treturn this;\n}\n\n\n\n// Autoregression method: MaxEntropy\ntimeseries.prototype.ARMaxEntropy = function(options) {\n\t// Credits to Alex Sergejew, Nick Hawthorn, Rainer Hegger (1998)\n\t// Zero-Indexed arrays modification by Paul Sanders (the arrays were One-indexed, FORTRAN style)\n\t// Ported to Javascript by Julien Loutre for timeseries-analysis, from Paul Bourke's C code.\n\t\n\toptions = _.extend({\n\t\tdegree:\t\t\t5,\n\t\tdata:\t\t\tthis.data,\n\t\tintermediates:\tfalse\t// Generates and returns the intermediates, a 2D array, instead of the coefficients.\n\t}, options);\n\t\n\tvar scope\t= this;\n\tvar i;\n\tvar length \t= options.data.length;\n\tvar pef \t= this.fill(0, length);\n\tvar per \t= this.fill(0, length);\n\tvar ar \t\t= this.fill([], options.degree+1);\n\tar\t\t\t= _.map(ar, function(d1) {\n\t\treturn scope.fill(0, options.degree+1);\n\t});\n\tvar h \t\t= this.fill(0, length);\n\tvar g\t\t= this.fill(0, options.degree+2);\n\t\n\tvar t1, t2;\n\tvar n;\n\t\n\tvar coef\t= [];\n\t\n\tfor (n=1; n <= options.degree; n++)\n\t{\n\t\tvar sn = 0.0;\n\t\tvar sd = 0.0;\n\t\tvar j;\n\t\tvar jj = length - n;\n\t\n\t\tfor (j = 0; j < jj; j++)\n\t\t{\n\t\t\tt1 = options.data[j + n][1] + pef[j];\n\t\t\tt2 = options.data[j][1] + per[j];\n\t\t\tsn -= 2.0 * t1 * t2;\n\t\t\tsd += (t1 * t1) + (t2 * t2);\n\t\t}\n\t\n\t\tt1 = g[n] = sn / sd;\n\t\tif (n != 1)\n\t\t{\n\t\t\tfor (j = 1; j < n; j++) {\n\t\t\t\th[j] = g[j] + t1 * g[n - j];\n\t\t\t}\n\t\t\tfor (j = 1; j < n; j++) {\n\t\t\t\tg[j] = h[j];\n\t\t\t}\n\t\t\tjj--;\n\t\t}\n\t\n\t\tfor (j = 0; j < jj; j++)\n\t\t{\n\t\t\tper [j] += t1 * pef[j] + t1 * options.data[j + n][1];\n\t\t\tpef [j] = pef[j + 1] + t1 * per[j + 1] + t1 * options.data[j + 1][1];\n\t\t}\n\t\n\t\tif (options.intermediates) {\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tar[n][j] = g[j + 1];\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tif (!options.intermediates) {\n\t\tfor (n = 0; n < options.degree; n++) {\n\t\t\tcoef[n] = g[n + 1];\n\t\t}\n\t\treturn coef;\n\t} else {\n\t\treturn ar;\n\t}\n\t\n}\n\n\n// Autoregression method: Least Square\ntimeseries.prototype.ARLeastSquare = function(options) {\n\t// Credits to Rainer Hegger (1998)\n\t// Ported to Javascript by Julien Loutre for timeseries-analysis, from Paul Bourke's C code.\n\tvar scope = this;\n\t\n\toptions = _.extend({\n\t\tdegree:\t\t\t5,\n\t\tdata:\t\t\tthis.data\n\t}, options);\n\t\n\tvar i,j,k,hj,hi;\n\tvar coefficients = [];\n\t\n\tvar length \t= options.data.length;\n\tvar mat \t= this.fill([], options.degree);\n\tmat\t\t\t= _.map(mat, function(d1) {\n\t\treturn scope.fill(0, options.degree);\n\t});\n\t\n\tfor (i=0;i < options.degree;i++) {\n\t\tcoefficients[i] = 0.0;\n\t\tfor (j=0;j< options.degree;j++) {\n\t\t\tmat[i][j] = 0.0;\n\t\t}\n\t}\n\tfor (i=options.degree-1;i < length-1;i++) {\n\t\thi = i + 1;\n\t\tfor (j=0;j < options.degree;j++) {\n\t\t\thj = i - j;\n\t\t\tcoefficients[j] += (options.data[hi][1] * options.data[hj][1]);\n\t\t\tfor (k=j;k < options.degree;k++) {\n\t\t\t\tmat[j][k] += (options.data[hj][1] * options.data[i-k][1]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i=0;i < options.degree;i++) {\n\t\tcoefficients[i] /= (length - options.degree);\n\t\tfor (j=i;j < options.degree;j++) {\n\t\t\tmat[i][j] /= (length - options.degree);\n\t\t\tmat[j][i] = mat[i][j];\n\t\t}\n\t}\n\t\n\tvar solved = this.SolveLE(mat,coefficients,options.degree);\n\t\n\treturn coefficients;\n\t\n}\n\ntimeseries.prototype.SolveLE = function(mat, vec, n) {\n\t// Gaussian elimination solver.\n\t// Use the coefficients from the Least Square method and make it into the real AR coefficients.\n\t// Original code by Rainer Hegger (1998). Modified by Paul Bourke.\n\t// Ported to Javascript by Julien Loutre for timeseries-analysis, from Paul Bourke's C code.\n\t\n\tvar i,j,k,maxi;\n\tvar vswap \t\t= [];\n\tvar mswap \t\t= [];\n\tvar hvec \t\t= [];\n\tvar max,h,pivot,q;\n\t\n\tfor (i=0;i<n-1;i++) {\n\t\tmax = Math.abs(mat[i][i]);\n\t\tmaxi = i;\n\t\tfor (j=i+1;j<n;j++) {\n\t\t\tif ((h = Math.abs(mat[j][i])) > max) {\n\t\t\t\tmax = h;\n\t\t\t\tmaxi = j;\n\t\t\t}\n\t\t}\n\t\tif (maxi != i) {\n\t\t\tmswap     = mat[i];\n\t\t\tmat[i]    = mat[maxi];\n\t\t\tmat[maxi] = mswap;\n\t\t\tvswap     = vec[i];\n\t\t\tvec[i]    = vec[maxi];\n\t\t\tvec[maxi] = vswap;\n\t\t}\n\t\n\t\thvec = mat[i];\n\t\tpivot = hvec[i];\n\t\tif (Math.abs(pivot) == 0.0) {\n\t\t\tconsole.log(\"Singular matrix - fatal!\");\n\t\t\treturn false;\n\t\t}\n\t\tfor (j=i+1;j<n;j++) {\n\t\t\tq = - mat[j][i] / pivot;\n\t\t\tmat[j][i] = 0.0;\n\t\t\tfor (k=i+1;k<n;k++) {\n\t\t\t\tmat[j][k] += q * hvec[k];\n\t\t\t}\n\t\t\tvec[j] += (q * vec[i]);\n\t\t}\n\t}\n\tvec[n-1] /= mat[n-1][n-1];\n\tfor (i=n-2;i>=0;i--) {\n\t\thvec = mat[i];\n\t\tfor (j=n-1;j>i;j--) {\n\t\t\tvec[i] -= (hvec[j] * vec[j]);\n\t\t}\n\t\tvec[i] /= hvec[i];\n\t}\n\t\n\treturn vec;\n}\n\n// Regression analysis. Will most likely be re-written in the future.\ntimeseries.prototype.regression_analysis = function(options) {\n\t// Original code by Professor Hossein Arsham - http://home.ubalt.edu/ntsbarsh/Business-stat/otherapplets/Trend.htm\n\t// Re-written for timeseries-analysis.\n\t\n\toptions = _.extend({\n\t\tthreshold:\t2.5\n\t}, options);\n\t\n\tvar output \t= {};\n\t\n\tvar i;\n\tvar j;\n\tvar E \t\t= this.data.length;  //total number of input spaces\n\tvar N \t\t= 0;\n\tvar N1 \t\t= 0;\n\tvar N2 \t\t= 0;\n\tvar SUM \t= 0.0;\n\tvar R \t\t= 1;\n\tvar Median\t= 0;\n\tvar theList = new Array();\n\tvar cval \t= new Array();\n\t// Run through all the input, add those that have valid values\n\tvar a\t\t= 0;\n\tfor(i=0;i < E;i++) \t{\n\t\tSUM \t\t+= this.data[i][1];\n\t\ttheList[a] \t= this.data[i][1];\n\t\tcval[a] \t= this.data[i][1];\n\t\tN++;\n\t\ta++;\n\t}\n\t//check for insufficient data\n\tif(N <= 10) {\n\t\tconsole.log(\"Insufficient data (min 10)\");\n\t\treturn false;\n\t}\n\t//sort the list\n\tfor(i=0; i<theList.length-1; i++) {\n\t\tfor(j=i+1;j<theList.length; j++) {\n\t\t\tif (theList[j] < theList[i])  {\n\t\t\t\ttemp \t\t= theList[i];\n\t\t\t\ttheList[i] \t= theList[j];\n\t\t\t\ttheList[j] \t= temp;\n\t\t\t}\n\t\t}\n\t}\n\t//calculate Median\n\tvar aux = 0;\n\tif(N%2 == 1) {\n\t\taux \t= Math.floor(N/2);\n\t\tMedian \t= theList[aux];\n\t} else {\n\t\tMedian \t= (theList[N/2]+theList[((N/2)-1)])/2;\n\t}\n\t\n\t// Do the math\n\tvar x = Median;\n\tvar y = Math.round(100000*x);\n\tvar z = y/100000;\n\t// run through each value and compare it with mean\n\tfor(i = 0; i < E; i++)     {\n\t\t//check if a value is present and discard the ties\n\t\tif(this.data[i][1] != x)  {\n\t\t\t//check if it is greater than mean then adds one\n\t\t\tif (this.data[i][1] > x)\t\t {\n\t\t\t\tN1++;\n\t\t\t\ta = i;\n\t\t\t\twhile (a > 0)  {\n\t\t\t\t\ta--;\n\t\t\t\t\tif(this.data[a][1] != x) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.data[a][1] < x) {\n\t\t\t\t\tR++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if it is less than mean\n\t\t\telse if (this.data[i][1] < x)   {\n\t\t\t\tN2++;\n\t\t\t\ta = i;\n\t\t\t\twhile (a > 0) {\n\t\t\t\t\ta--;\n\t\t\t\t\tif(this.data[a][1] != x)   {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.data[a][1] > x)  {\n\t\t\t\t\tR++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//form.NR.value = R;     //value of x or \"Scores\"\n\t// What is the runs' statistic? I don't know...\n\t// Is it http://en.wikipedia.org/wiki/Wald%E2%80%93Wolfowitz_runs_test ?\n\toutput.runs\t= R;\n\t\n\n\t//compute the expected mean and variance of R\n\tvar EM \t= 1 + (2*N1*N2)/(N1+N2);           //Mean \"Mu\"\n\tvar SD1 = [2*N1*N2*(2*N1*N2-N1-N2)];\n\tvar SD2 = Math.pow( (N1 + N2), 2);\n\tvar SD3 = N1 + N2 - 1;\n\tvar SD4 = SD1 / (SD2 * SD3);           //Standard deviation \"Sigma\"\n\tvar SD \t= Math.sqrt(SD4);\n\t//calculating P value MStyle\n\tvar z1 \t= (R - EM)/SD;\n\tvar z2 \t= Math.abs(z1);\n\tvar z \t= z2;\n\t\n\t/* Thanks to Jan de Leeuw for the following function */\n\tvar t \t= (z > 0) ? z : (-z);\n\tvar P1 \t= Math.pow((1+t*(0.049867347 + t*(0.0211410061 + t*(0.0032776263 + t*(0.0000380036 + t*(0.0000488906 + t*(0.000005383))))))), -16);\n\tvar p \t= 1 - P1 / 2;\n\tvar t \t= 1-((z > 0) ? p : 1-p);         //this is P-value\n\t\n\t//rounding the value\n\tvar t1 \t= Math.round(100000*t);\n\tvar t2 \t= t1/100000;                  //this is P-value too\n\t//form.PV.value = t2;\n\n\t//determine the conclusion\n\t// Encoding the trend value from 0 (no trend) to 3 (strong strend evidence)\n\tif (t2 < 0.01)   {\n\t\t//form.CON.value = \"Strong evidence for trend\";\n\t\toutput.trend\t= 3;\n\t} else if (t2 < 0.05 && t2 >= 0.01)  {\n\t\t//form.CON.value = \"Moderate evidence for trend\";\n\t\toutput.trend\t= 2;\n\t} else if (t2 < 0.10 && t2 >= 0.05)  {\n\t\t//form.CON.value = \"Suggestive evidence for trend\";\n\t\toutput.trend\t= 1;\n\t} else if (t2 >= 0.10)   {\n\t\t//form.CON.value = \"Little or no real evidences for trend\";\n\t\toutput.trend\t= 0;\n\t} else {\n\t\t//form.CON.value = \"Strong evidence for trend\";\n\t\toutput.trend\t= 3;\n\t}\n\n\t//AUTO CORRELATION\n\tvar DWNN = 0;\n\tvar DWND = (cval[0]*cval[0]);\n\tfor (i=1; i<cval.length; i++)  {\n\t\tDWNN = DWNN +(cval[i]- cval[i-1])*(cval[i]-cval[i-1]) ;\n\t\tDWND = DWND +(cval[i]*cval[i]);\n\t}\n\tvar DW = DWNN/DWND;\n\tDW = Math.round(DW*100000)/100000;\n\t//form.DW.value = DW;\n\toutput.durbinWatson\t= DW;\n\t\n\tvar Q01 \t= 2-4.6527/(Math.sqrt(N+2));\n\tvar Q05 \t= 2-3.2897/(Math.sqrt(N+2));\n\t\n\t//determine the conclusion\n\t// Encode the correlation between 1 and 3\n\tif((DW>=Q01) || (DW<=(4 - Q01)))  {\n\t\t//form.COND.value = \"Moderate evidence againt autocorrelation\";\n\t\toutput.autocorrelation\t= 2;\n\t} else if((DW >= Q05)&&(DW<=(4 - Q05))) {\n\t\t//form.COND.value = \"Strong evidences against autocorrelation\";\n\t\toutput.autocorrelation\t= 3;\n\t} else {\n\t\t//form.COND.value = \"Suggestive evidences for autocorrelation\";\n\t\toutput.autocorrelation\t= 1;\n\t}\n\t\n\treturn output;\n}\n\n// Get the Durbin-Watson statistic\n// http://en.wikipedia.org/wiki/Durbin%E2%80%93Watson_statistic\ntimeseries.prototype.durbinWatson = function() {\n\treturn this.regression_analysis().durbinWatson;\n}\n\n// Get the Durbin-Watson statistic\n// http://en.wikipedia.org/wiki/Durbin%E2%80%93Watson_statistic\ntimeseries.prototype.regression_analysis = function() {\n\treturn this.regression_analysis().durbinWatson;\n}\n\n\n\n\n// Data adapters\nvar adapter = {\n\t\n};\nadapter.fromDB = function(data, options) {\n\toptions = _.extend({\n\t\tvalue:\t\t'close',\n\t\tdate:\t\t'date'\n\t}, options);\n\t\n\treturn _.map(data, function(datapoint) {\n\t\treturn [new Date(datapoint[options.date]).getTime(), datapoint[options.value]];\n\t});\n};\nadapter.fromArray = function(data) {\n\treturn _.map(data, function(datapoint) {\n\t\treturn [new Date(), datapoint];\n\t});\n};\nadapter.geometric = function(options) {\n\toptions = _.extend({\n\t}, options);\n\t\n\t\n\tvar i;\n\tvar j;\n\tvar output = [];\n\tfor (i=0;i<128;i++) {\n\t\toutput.push([\n\t\t\tnew Date(),\n\t\t\tMath.cos(i*0.01)+0.75*Math.cos(i*0.03)+0.5*Math.cos(i*0.05)+0.25*Math.cos(i*0.11)\n\t\t]);\n\t}\n\treturn output;\n};\nadapter.complex = function(options) {\n\toptions = _.extend({\n\t\tcycles:\t\t10,\n\t\tquality:\t1,\n\t\tinertia:\t0\n\t}, options);\n\t\n\t\n\tvar i;\n\tvar j;\n\tvar output = [];\n\tfor (i=0;i<options.cycles;i++) {\n\t\tfor (j=0;j<360;j+=options.quality) {\n\t\t\toutput.push([\n\t\t\t\tnew Date(),\n\t\t\t\t(Math.sin(j*Math.PI/180)+Math.cos(j*3*Math.PI/180)-Math.sin(j*2.4*Math.PI/180))*100\n\t\t\t]);\n\t\t\toptions.quality += options.inertia;\n\t\t}\n\t}\n\treturn output;\n};\nadapter.sin = function(options) {\n\toptions = _.extend({\n\t\tcycles:\t\t4,\n\t\tquality:\t2,\n\t\tinertia:\t0\t\n\t}, options);\n\t\n\tvar i;\n\tvar j;\n\tvar output \t= [];\n\tfor (i=0;i<options.cycles;i++) {\n\t\tfor (j=0;j<360;j+=options.quality) {\n\t\t\toutput.push([\n\t\t\t\tnew Date(),\n\t\t\t\tMath.cos(j*Math.PI/180)*100\n\t\t\t]);\n\t\t\toptions.quality += options.inertia;\n\t\t}\n\t\tconsole.log(\"options.quality\",options.quality);\n\t}\n\treturn output;\n};\nadapter.tan = function(options) {\n\toptions = _.extend({\n\t\tcycles:\t\t1\n\t}, options);\n\tvar i;\n\tvar j;\n\tvar output = [];\n\tfor (i=0;i<options.cycles;i++) {\n\t\tfor (j=0;j<360;j++) {\n\t\t\toutput.push([\n\t\t\t\tnew Date(),\n\t\t\t\tMath.tan(j*Math.PI/180)\n\t\t\t]);\n\t\t}\n\t}\n\treturn output;\n};\n\n\nexports.main\t\t= timeseries;\nexports.adapter\t\t= adapter;\nexports.version\t\t= \"1.0.11\";"}